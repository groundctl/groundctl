package rabbitmq

import (
	"context"
	"encoding/json"

	amqp "github.com/rabbitmq/amqp091-go"
)

const (
	{{ $.Name | capitalize -}}Queue_Name       = "{{ $.Name }}"
	{{ $.Name | capitalize -}}Queue_Durable    = {{ printf "%t" $.Durable }}
	{{ $.Name | capitalize -}}Queue_AutoDelete = {{ printf "%t" $.AutoDelete }}
	{{ $.Name | capitalize -}}Queue_Exclusive  = {{ printf "%t" $.Exclusive }}
	{{ $.Name | capitalize -}}Queue_NoWait     = {{ printf "%t" $.NoWait }}
	{{ $.Name | capitalize -}}Vhost            = "{{- $.Vhost -}}"
)

func {{ $.Name }}Queue(conn *amqp.Connection) (*amqp.Channel, amqp.Queue, error) {
	ch, err := conn.Channel()
	if err != nil {
		return nil, amqp.Queue{}, err
	}

	q, err := ch.QueueDeclare(
		{{ $.Name | capitalize -}}Queue_Name,
		{{ $.Name | capitalize -}}Queue_Durable,
		{{ $.Name | capitalize -}}Queue_AutoDelete,
		{{ $.Name | capitalize -}}Queue_Exclusive,
		{{ $.Name | capitalize -}}Queue_NoWait,
		nil,
	)

	return ch, q, err
}

type {{ $.Name -}}Listener struct {
	ch   *amqp.Channel
	msgs <-chan amqp.Delivery
}

func New{{ $.Name | capitalize -}}Listener(ctx context.Context, conn *amqp.Connection) (*{{ $.Name }}Listener, error) {
	ch, q, err := {{ $.Name }}Queue(conn)
	if err != nil {
		return nil, err
	}

	msgs, err := ch.ConsumeWithContext(
		ctx,
		q.Name,
		"",
		true,
		false,
		false,
		false,
		nil,
	)
	if err != nil {
		return nil, err
	}

	return &{{- $.Name -}}Listener{
		ch:   ch,
		msgs: msgs,
	}, nil
}

func (l *{{- $.Name -}}Listener) Close() error {
	return l.ch.Close()
}

func (l *{{- $.Name -}}Listener) Consume(ctx context.Context) (*{{ $.Name | capitalize | singular }}, error) {
	select {
	case <-ctx.Done():
		return nil, nil
	case msg := <-l.msgs:
		var {{ $.Name | singular }} {{ $.Name | capitalize | singular }}
		err := json.Unmarshal(msg.Body, &{{ $.Name | singular }})
		if err != nil {
			return nil, err
		}

		return &{{- $.Name | singular }}, nil
	}
}

type {{ $.Name -}}Client struct {
	ch *amqp.Channel
	q  amqp.Queue
}

func New{{- $.Name | capitalize -}}Client(conn *amqp.Connection) (*{{ $.Name }}Client, error) {
	ch, q, err := {{ $.Name }}Queue(conn)
	if err != nil {
		return nil, err
	}

	return &{{- $.Name -}}Client{
		ch: ch,
		q:  q,
	}, nil
}

func (c *{{- $.Name -}}Client) Close() error {
	return c.ch.Close()
}

func (c *{{- $.Name -}}Client) Send(ctx context.Context, obj {{ $.Name | capitalize | singular }}) error {
	out, err := json.Marshal(obj)
	if err != nil {
		return err
	}

	err = c.ch.PublishWithContext(
		ctx,
		"",
		c.q.Name,
		false,
		false,
		amqp.Publishing{
			ContentType: "application/json",
			Body:        out,
		},
	)
	if err != nil {
		return err
	}

	return nil
}
