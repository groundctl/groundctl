// Code generated by gen.go; DO NOT EDIT.
// source: queues.yml

package rabbitmq

import (
	"context"
	"encoding/json"

	amqp "github.com/rabbitmq/amqp091-go"
)

// "/deployRequests" Queue

const (
	// The name of the "deploy_requests" queue
	DeployRequestsQueue_Name = "deploy_requests"
	// Durable setting for the "deploy_requests" queue
	DeployRequestsQueue_Durable = false
	// Auto Delete setting for the "deploy_requests" queue
	DeployRequestsQueue_AutoDelete = false
	// Exclusive setting for the "deploy_requests" queue
	DeployRequestsQueue_Exclusive = false
	// No Wait setting for the "deploy_requests" queue
	DeployRequestsQueue_NoWait = false
	// Vhost name for the "deploy_requests" queue
	DeployRequestsVhost = ""
)

// Create a new "deploy_requests" queue
func newDeployRequestsQueue(client *DefaultClient) (*amqp.Channel, amqp.Queue, error) {
	ch, err := client.Channel()
	if err != nil {
		return nil, amqp.Queue{}, err
	}

	q, err := ch.QueueDeclare(
		DeployRequestsQueue_Name,
		DeployRequestsQueue_Durable,
		DeployRequestsQueue_AutoDelete,
		DeployRequestsQueue_Exclusive,
		DeployRequestsQueue_NoWait,
		nil,
	)

	return ch, q, err
}

// deployRequestsConsumer represents a consumer client connection to the "deploy_requests" queue
type deployRequestsConsumer struct {
	ch   *amqp.Channel
	msgs <-chan amqp.Delivery
}

// NewDeployRequestsConsumer creates a new queue consumer client connected to the "deploy_requests" queue
func NewDeployRequestsConsumer(ctx context.Context, client *DefaultClient) (*deployRequestsConsumer, error) {
	ch, q, err := newDeployRequestsQueue(client)
	if err != nil {
		return nil, err
	}

	msgs, err := ch.ConsumeWithContext(
		ctx,
		q.Name,
		"",
		true,
		false,
		DeployRequestsQueue_Exclusive,
		DeployRequestsQueue_NoWait,
		nil,
	)
	if err != nil {
		return nil, err
	}

	return &deployRequestsConsumer{
		ch:   ch,
		msgs: msgs,
	}, nil
}

// Closes the the channel opened to the "deploy_requests" queue
func (l *deployRequestsConsumer) Close() error {
	return l.ch.Close()
}

// Consume will automatically unmarshal incoming messages as [DeployRequest]. It produces the output and any unmarshalling errors on the returned channels.
func (l *deployRequestsConsumer) Consume(ctx context.Context) (chan DeployRequest, chan error) {
	out := make(chan DeployRequest)
	errs := make(chan error)
	go func() {
		select {
		case <-ctx.Done():
			return
		case msg := <-l.msgs:
			var deployRequest DeployRequest
			err := json.Unmarshal(msg.Body, &deployRequest)
			if err != nil {
				errs <- err
				break
			}

			out <- deployRequest
		}
	}()
	return out, errs
}

// deployRequestsProducer represents a producer client connection to the "deploy_requests" queue
type deployRequestsProducer struct {
	ch *amqp.Channel
	q  amqp.Queue
}

// NewDeployRequestsProducer creates a new queue producer client connected to the "deploy_requests" queue
func NewDeployRequestsProducer(client *DefaultClient) (*deployRequestsProducer, error) {
	ch, q, err := newDeployRequestsQueue(client)
	if err != nil {
		return nil, err
	}

	return &deployRequestsProducer{
		ch: ch,
		q:  q,
	}, nil
}

// Closes the the channel opened to the "deploy_requests" queue
func (c *deployRequestsProducer) Close() error {
	return c.ch.Close()
}

// Produce sends a [DeployRequest] message to the "deploy_requests" queue
func (c *deployRequestsProducer) Produce(ctx context.Context, obj DeployRequest) error {
	out, err := json.Marshal(obj)
	if err != nil {
		return err
	}

	err = c.ch.PublishWithContext(
		ctx,
		"",
		c.q.Name,
		false,
		false,
		amqp.Publishing{
			ContentType: "application/json",
			Body:        out,
		},
	)
	if err != nil {
		return err
	}

	return nil
}
