// Code generated by gen.go; DO NOT EDIT.
// source: queues.yml

package rabbitmq

import (
	"context"
	"encoding/json"

	amqp "github.com/rabbitmq/amqp091-go"
)

{{ range $q := . -}}

{{- $vhostName := "" -}}
{{- if ne $q.Vhost "default" -}}
	{{- $vhostName = $q.Vhost -}}
{{- end -}}

// "{{ $vhostName }}/{{ $q.Name | lowerCamel }}" Queue

const (
	// The name of the "{{ $q.Name }}" queue
	{{ $q.Name | camel -}}Queue_Name       = "{{ $q.Name }}"
	// Durable setting for the "{{ $q.Name }}" queue
	{{ $q.Name | camel -}}Queue_Durable    = {{ printf "%t" $q.Durable }}
	// Auto Delete setting for the "{{ $q.Name }}" queue
	{{ $q.Name | camel -}}Queue_AutoDelete = {{ printf "%t" $q.AutoDelete }}
	// Exclusive setting for the "{{ $q.Name }}" queue
	{{ $q.Name | camel -}}Queue_Exclusive  = {{ printf "%t" $q.Exclusive }}
	// No Wait setting for the "{{ $q.Name }}" queue
	{{ $q.Name | camel -}}Queue_NoWait     = {{ printf "%t" $q.NoWait }}
	// Vhost name for the "{{ $q.Name }}" queue
	{{ $q.Name | camel -}}Vhost            = "{{ $vhostName }}"
)

// Create a new "{{ $q.Name }}" queue
func new{{ $q.Name | camel }}Queue(client *{{ $q.Vhost | camel }}Client) (*amqp.Channel, amqp.Queue, error) {
	ch, err := client.Channel()
	if err != nil {
		return nil, amqp.Queue{}, err
	}

	q, err := ch.QueueDeclare(
		{{ $q.Name | camel -}}Queue_Name,
		{{ $q.Name | camel -}}Queue_Durable,
		{{ $q.Name | camel -}}Queue_AutoDelete,
		{{ $q.Name | camel -}}Queue_Exclusive,
		{{ $q.Name | camel -}}Queue_NoWait,
		nil,
	)

	return ch, q, err
}

// {{ $q.Name | lowerCamel -}}Consumer represents a consumer client connection to the "{{ $q.Name }}" queue 
type {{ $q.Name | lowerCamel -}}Consumer struct {
	ch   *amqp.Channel
	msgs <-chan amqp.Delivery
}

// New{{ $q.Name | camel -}}Consumer creates a new queue consumer client connected to the "{{ $q.Name }}" queue
func New{{ $q.Name | camel -}}Consumer(ctx context.Context, client *{{ $q.Vhost | camel }}Client) (*{{ $q.Name | lowerCamel }}Consumer, error) {
	ch, q, err := new{{ $q.Name | camel }}Queue(client)
	if err != nil {
		return nil, err
	}

	msgs, err := ch.ConsumeWithContext(
		ctx,
		q.Name,
		"",
		true,
		false,
		{{ $q.Name | camel -}}Queue_Exclusive,
		{{ $q.Name | camel -}}Queue_NoWait,
		nil,
	)
	if err != nil {
		return nil, err
	}

	return &{{ $q.Name | lowerCamel -}}Consumer{
		ch:   ch,
		msgs: msgs,
	}, nil
}

// Closes the the channel opened to the "{{ $q.Name }}" queue
func (l *{{ $q.Name | lowerCamel -}}Consumer) Close() error {
	return l.ch.Close()
}

// Consume will automatically unmarshal incoming messages as [{{ $q.Name | camel | singular }}]. It produces the output and any unmarshalling errors on the returned channels.
func (l *{{ $q.Name | lowerCamel -}}Consumer) Consume(ctx context.Context) (chan {{ $q.Name | camel | singular }}, chan error) {
	out := make(chan {{ $q.Name | camel | singular }})
	errs := make(chan error)
	go func() {
		select {
		case <-ctx.Done():
			return
		case msg := <-l.msgs:
			var {{ $q.Name | lowerCamel | singular }} {{ $q.Name | camel | singular }}
			err := json.Unmarshal(msg.Body, &{{ $q.Name | lowerCamel | singular }})
			if err != nil {
				errs <- err
				break
			}
	
			out <- {{ $q.Name | lowerCamel | singular }}
		}
	}()
	return out, errs
}

// {{ $q.Name | lowerCamel -}}Producer represents a producer client connection to the "{{ $q.Name }}" queue
type {{ $q.Name | lowerCamel }}Producer struct {
	ch *amqp.Channel
	q  amqp.Queue
}

// New{{ $q.Name | camel -}}Producer creates a new queue producer client connected to the "{{ $q.Name }}" queue
func New{{- $q.Name | camel -}}Producer(client *{{ $q.Vhost | camel }}Client) (*{{ $q.Name | lowerCamel }}Producer, error) {
	ch, q, err := new{{ $q.Name | camel }}Queue(client)
	if err != nil {
		return nil, err
	}

	return &{{ $q.Name | lowerCamel -}}Producer{
		ch: ch,
		q:  q,
	}, nil
}

// Closes the the channel opened to the "{{ $q.Name }}" queue
func (c *{{ $q.Name | lowerCamel -}}Producer) Close() error {
	return c.ch.Close()
}

// Produce sends a [{{ $q.Name | camel | singular }}] message to the "{{ $q.Name }}" queue
func (c *{{ $q.Name | lowerCamel -}}Producer) Produce(ctx context.Context, obj {{ $q.Name | camel | singular }}) error {
	out, err := json.Marshal(obj)
	if err != nil {
		return err
	}

	err = c.ch.PublishWithContext(
		ctx,
		"",
		c.q.Name,
		false,
		false,
		amqp.Publishing{
			ContentType: "application/json",
			Body:        out,
		},
	)
	if err != nil {
		return err
	}

	return nil
}

{{ end }}